# -*- coding: utf-8 -*-
"""wine-quality-prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/Tanishqa23/869564dd9ea35b58a3a9146524ed3cd9/wine-quality-prediction.ipynb

**Wine Quality Prediction using Support Vector Machine**

**Get Understanding about Data set**

White wine data has twelve variables.
1. fixed acidity
2. volatile acidity
3. citric acid
4. residual sugar
5. chlorides
6. free sulfur dioxide
7. total sulfur dioxide
8. density
9. ph
10. sulphates
11. alcohol
12. quality

**Import Library**
"""

import pandas as pd

import numpy as np

"""**Import CSV as DataFrame**

Use URL of file directly
"""

df = pd.read_csv('https://github.com/YBI-Foundation/Dataset/raw/main/WhiteWineQuality.csv', sep=';')

"""**or use local file path in Jupyter Notebook**"""

# df = pd.read_csv(r'C:\Users\YBI Foundation\Desktop\WhiteWineQuality.csv')

"""**or use file path after uploading file in Google Colab Notebook**"""

# df = pd.read_csv(r'/content/WhiteWineQuality.csv')

"""**Get the First Five Rows of Dataframe**"""

df.head()

"""**Get Information of DataFrame**"""

df.info()

"""**Get the Summary Statistics**"""

df.describe()

"""**Get Column Names**"""

df.columns

"""**Get Shape of DataFrame**"""

df.shape

"""**Get Unique Values (Class or Label) in y Variable**"""

df['quality'].value_counts()

df.groupby('quality').mean()

"""**Define y (dependent or label or target variable) and X (independent or features or attribute Variable)**"""

y= df['quality']

y.shape

y

X = df[['fixed acidity', 'volatile acidity', 'citric acid', 'residual sugar',
       'chlorides', 'free sulfur dioxide', 'total sulfur dioxide', 'density',
       'pH', 'sulphates', 'alcohol']]

"""or use .drop function to define X"""

X = df.drop(['quality'], axis=1)

X.shape

X

"""**Get X Variables Standardized**

Standardization of datasets is a common requirement for many machine learning estimators implemented in scikit-learn; they might behave badly if the individual features do not more or less look like standard normally distributed data: Gaussian with zero mean and unit variance.

Next approach is go for MinMax Scaler
"""

from sklearn.preprocessing import StandardScaler

ss = StandardScaler()

X = ss.fit_transform(X)

X

"""**Get Train Test Split**"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, stratify=y, random_state=2529)

X_train.shape, X_test.shape, y_train.shape, y_test.shape

"""**Get Model Train**"""

from sklearn.svm import SVC

svc = SVC()

svc.fit(X_train, y_train)

"""**Get Model Prediction**"""

y_pred = svc.predict(X_test)

y_pred.shape

y_pred

"""**Get Model Evaluation**"""

from sklearn.metrics import confusion_matrix, classification_report

print(confusion_matrix(y_test, y_pred))

print(classification_report(y_test, y_pred))

"""**Get Model Re-run with Two Class Created for Wine Quality**

Wine Quality 3,4,5 labelled as 0
Wine Quality 6,7,8,9 labelled as 1
"""

y= df['quality'].apply(lambda y_value: 1 if y_value>=6 else 0)

y.value_counts()

"""**Get Train Test Split**"""

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, stratify=y, random_state=2529)

X_train.shape, X_test.shape, y_train.shape, y_test.shape

"""**Get Model Train**"""

from sklearn.svm import SVC

svc = SVC()

svc.fit(X_train, y_train)

"""**Get Model Prediction**"""

y_pred = svc.predict(X_test)

y_pred.shape

y_pred

"""**Get Model Evaluation**"""

from sklearn.metrics import confusion_matrix, classification_report

print(confusion_matrix(y_test, y_pred))

print(classification_report(y_test, y_pred))

"""**Get Future Predictions**

**Lets select a random sample from existing dataset as new value**
Steps to follow
1. Extract a radom row using sample function
2. Seperate X and y
3. Standardize X
4. Predict
"""

df_new = df.sample(1)

df_new

df_new.shape

X_new = df_new.drop(['quality'], axis=1)

X_new = ss.fit_transform(X_new)

y_pred_new = svc.predict(X_new)

y_pred_new